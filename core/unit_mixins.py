# core/unit_mixins.py
import random
from typing import Dict, List, Tuple, Any, TYPE_CHECKING
from core.enums import DiceType
# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∫–ª–∞—Å—Å—ã –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞—Ä—Ç –Ω–∞ –ª–µ—Ç—É
from core.card import Card
from core.dice import Dice

if TYPE_CHECKING:
    from core.unit import Unit


class UnitStatusMixin:
    # ... (–∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
    def _ensure_status_storage(self):
        if not hasattr(self, "_status_effects"): self._status_effects = {}
        if not hasattr(self, "delayed_queue"): self.delayed_queue = []

    @property
    def statuses(self) -> Dict[str, int]:
        self._ensure_status_storage()
        summary = {}
        for name, instances in self._status_effects.items():
            total = sum(i["amount"] for i in instances)
            if total > 0:
                summary[name] = total
        return summary

    def add_status(self, name: str, amount: int, duration: int = 1, delay: int = 0):
        self._ensure_status_storage()
        if amount <= 0: return

        if delay > 0:
            self.delayed_queue.append({
                "name": name, "amount": amount, "duration": duration, "delay": delay
            })
            return

        if name not in self._status_effects:
            self._status_effects[name] = []

        self._status_effects[name].append({"amount": amount, "duration": duration})

    def get_status(self, name: str) -> int:
        self._ensure_status_storage()
        if name not in self._status_effects: return 0
        return sum(i["amount"] for i in self._status_effects[name])

    def remove_status(self, name: str, amount: int = None):
        self._ensure_status_storage()
        if name not in self._status_effects: return

        if amount is None:
            del self._status_effects[name]
            return

        items = sorted(self._status_effects[name], key=lambda x: x["duration"])
        rem = amount
        new_items = []

        for item in items:
            if rem <= 0:
                new_items.append(item)
                continue
            if item["amount"] > rem:
                item["amount"] -= rem
                rem = 0
                new_items.append(item)
            else:
                rem -= item["amount"]

        if not new_items:
            del self._status_effects[name]
        else:
            self._status_effects[name] = new_items


class UnitCombatMixin:
    """
    –ë–æ–µ–≤–∞—è –ª–æ–≥–∏–∫–∞: –±—Ä–æ—Å–∫–∏ –∏–Ω–∏—Ü–∏–∞—Ç–∏–≤—ã, –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è.
    """

    def roll_speed_dice(self):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤ –Ω–∞ —Ä–∞—É–Ω–¥."""
        self.active_slots = []

        if self.is_dead():
            return

        # 1. –û—Å–Ω–æ–≤–Ω—ã–µ –∫—É–±–∏–∫–∏ (—Ä–∞—Å—á–∏—Ç–∞–Ω–Ω—ã–µ –∏–∑ —Å—Ç–∞—Ç–æ–≤)
        for (d_min, d_max) in self.computed_speed_dice:
            mod = self.get_status("haste") - self.get_status("slow") - self.get_status("bind")
            val = max(1, random.randint(d_min, d_max) + mod)
            self.active_slots.append({
                'speed': val, 'card': None, 'target_slot': None, 'is_aggro': False
            })

        # 2. –ê–∫—Ç–∏–≤–Ω—ã–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ (–Ø—Ä–æ—Å—Ç—å - Berserker Rage)
        if self.active_buffs.get("berserker_rage", 0) > 0:
            d_min, d_max = self.computed_speed_dice[0] if self.computed_speed_dice else (self.base_speed_min,
                                                                                         self.base_speed_max)
            mod = self.get_status("haste") - self.get_status("slow") - self.get_status("bind")
            val = max(1, random.randint(d_min, d_max) + mod)

            self.active_slots.append({
                'speed': val, 'card': None, 'target_slot': None, 'is_aggro': False,
                'source_effect': 'Rage üò°'
            })

        # 3. –¢–ê–õ–ê–ù–¢: –ù–ï–ò–°–¢–û–í–°–¢–í–û (Frenzy)
        if "frenzy" in self.talents:
            # –î–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑—É —é–Ω–∏—Ç–∞
            d_min, d_max = self.base_speed_min, self.base_speed_max
            mod = self.get_status("haste") - self.get_status("slow") - self.get_status("bind")

            # --- –°–ª–æ—Ç 1: –í—Å–µ–≥–¥–∞ (5-7) ---
            val1 = max(1, random.randint(d_min, d_max) + mod)

            # –°–æ–∑–¥–∞–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—É—é –∫–∞—Ä—Ç—É
            card_frenzy_1 = Card(
                id="frenzy_atk_1", name="Frenzy (5-7)", tier=1, card_type="melee",
                description="Auto-generated by Frenzy Talent",
                dice_list=[Dice(5, 7, DiceType.SLASH)]  # –¢–∏–ø Slash –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            )

            self.active_slots.append({
                'speed': val1,
                'card': card_frenzy_1,  # –°—Ä–∞–∑—É –∫–ª–∞–¥–µ–º –∫–∞—Ä—Ç—É
                'target_slot': None,
                'is_aggro': False,
                'source_effect': 'Frenzy üî•',
                'locked': True  # <--- –§–ª–∞–≥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –≤—ã–±–æ—Ä–∞
            })

            # --- –°–ª–æ—Ç 2: –ï—Å–ª–∏ Self-Control > 10 (6-8) ---
            if self.get_status("self_control") > 10:
                val2 = max(1, random.randint(d_min, d_max) + mod)

                card_frenzy_2 = Card(
                    id="frenzy_atk_2", name="Frenzy II (6-8)", tier=2, card_type="melee",
                    description="Auto-generated by Frenzy (>10 SC)",
                    dice_list=[Dice(6, 8, DiceType.SLASH)]
                )

                self.active_slots.append({
                    'speed': val2,
                    'card': card_frenzy_2,
                    'target_slot': None,
                    'is_aggro': False,
                    'source_effect': 'Frenzy+ üî•',
                    'locked': True
                })

    def is_staggered(self) -> bool:
        return self.current_stagger <= 0

    def is_dead(self) -> bool:
        return self.current_hp <= 0


class UnitLifecycleMixin:
    # ... (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏–∑ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –∏–ª–∏ –æ—Å—Ç–∞–≤—å—Ç–µ –∫–∞–∫ –µ—Å—Ç—å)
    def heal_hp(self, amount: int) -> int:
        eff = 1.0 + self.modifiers.get("heal_efficiency", 0.0)
        final_amt = int(amount * eff)
        if self.get_status("deep_wound") > 0:
            final_amt = int(final_amt * 0.75)
            self.remove_status("deep_wound", 1)
        self.current_hp = min(self.max_hp, self.current_hp + final_amt)
        return final_amt

    def take_sanity_damage(self, amount: int):
        self.current_sp = max(-45, self.current_sp - amount)

    def tick_cooldowns(self):
        for k in list(self.cooldowns.keys()):
            self.cooldowns[k] -= 1
            if self.cooldowns[k] <= 0: del self.cooldowns[k]
        for k in list(self.active_buffs.keys()):
            self.active_buffs[k] -= 1
            if self.active_buffs[k] <= 0: del self.active_buffs[k]
        if self.is_dead(): self.active_buffs.clear()